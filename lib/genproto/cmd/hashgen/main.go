// Package main provides a tool for generating protocol IDs from proto message definitions
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/orbit-w/orbit/lib/utils/protoid"
)

var (
	protoDir  = flag.String("proto_dir", "app/proto", "Directory containing .proto files")
	outputDir = flag.String("output_dir", "app/proto/pb", "Directory for generated protocol ID files")
	debugMode = flag.Bool("debug", false, "Enable debug mode")
)

type ProtocolIDMapping struct {
	PackageName string
	MessageIDs  []MessageID
}

type MessageID struct {
	Name string
	ID   uint32
}

func main() {
	flag.Parse()

	// Ensure output directory exists
	if _, err := os.Stat(*outputDir); os.IsNotExist(err) {
		if err := os.MkdirAll(*outputDir, 0755); err != nil {
			fmt.Printf("Failed to create output directory: %v\n", err)
			return
		}
	}

	// Find all proto files
	protoFiles, err := findProtoFiles(*protoDir)
	if err != nil {
		fmt.Printf("Error finding proto files: %v\n", err)
		return
	}

	// Process each proto file to extract message names
	for _, protoFile := range protoFiles {
		if *debugMode {
			fmt.Printf("Processing %s...\n", protoFile)
		}

		// Read proto file content
		content, err := os.ReadFile(protoFile)
		if err != nil {
			fmt.Printf("Error reading file %s: %v\n", protoFile, err)
			continue
		}

		// Extract package name
		packageName := extractPackageName(string(content))
		if packageName == "" {
			fmt.Printf("Package name not found in %s\n", protoFile)
			continue
		}

		// Extract all message names
		messageNames := extractMessageNames(string(content))
		if len(messageNames) == 0 {
			if *debugMode {
				fmt.Printf("No message definitions found in %s\n", protoFile)
			}
			continue
		}

		// Generate protocol IDs for each message
		mapping := ProtocolIDMapping{
			PackageName: packageName,
		}

		// Sort message names for consistent output
		sort.Strings(messageNames)

		for _, msgName := range messageNames {
			fullName := fmt.Sprintf("%s.%s", packageName, msgName)
			pid := protoid.HashProtoMessage(fullName)
			mapping.MessageIDs = append(mapping.MessageIDs, MessageID{
				Name: msgName,
				ID:   pid,
			})

			if *debugMode {
				fmt.Printf("Message: %s, ID: 0x%08x\n", fullName, pid)
			}
		}

		// Generate the protocol ID file
		generateProtocolIDFile(mapping)
	}
}

// findProtoFiles finds all .proto files in the specified directory
func findProtoFiles(dir string) ([]string, error) {
	var files []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(path, ".proto") {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

// extractPackageName extracts the package name from a proto file
func extractPackageName(content string) string {
	re := regexp.MustCompile(`package\s+([^;]+);`)
	matches := re.FindStringSubmatch(content)
	if len(matches) > 1 {
		return strings.TrimSpace(matches[1])
	}
	return ""
}

// extractMessageNames extracts all top-level message names from a proto file
func extractMessageNames(content string) []string {
	var messageNames []string
	re := regexp.MustCompile(`message\s+(\w+)\s*\{`)
	matches := re.FindAllStringSubmatch(content, -1)
	for _, match := range matches {
		if len(match) > 1 {
			messageNames = append(messageNames, match[1])
		}
	}
	return messageNames
}

// generateProtocolIDFile generates a Go file with protocol ID constants
func generateProtocolIDFile(mapping ProtocolIDMapping) {
	// Output filename based on package name
	packageNameLower := strings.ToLower(mapping.PackageName)
	outputFile := filepath.Join(*outputDir, fmt.Sprintf("%s_protocol_ids.go", packageNameLower))

	// Sort message IDs by name for consistent output
	sort.Slice(mapping.MessageIDs, func(i, j int) bool {
		return mapping.MessageIDs[i].Name < mapping.MessageIDs[j].Name
	})

	// Template for the protocol ID constants file
	const tmpl = `// Code generated by protocol ID generator. DO NOT EDIT.
package pb

// Protocol IDs for {{.PackageName}} package messages
const (
{{- range .MessageIDs}}
	PID_{{$.PackageName}}_{{.Name}} uint32 = 0x{{printf "%08x" .ID}} // {{$.PackageName}}.{{.Name}}
{{- end}}
)

// MessageNameToID maps message names to their protocol IDs
var {{.PackageName}}MessageNameToID = map[string]uint32{
{{- range .MessageIDs}}
	"{{.Name}}": PID_{{$.PackageName}}_{{.Name}},
{{- end}}
}

// GetProtocolID returns the protocol ID for the given message name
func Get{{.PackageName}}ProtocolID(messageName string) (uint32, bool) {
	id, ok := {{.PackageName}}MessageNameToID[messageName]
	return id, ok
}
`

	// Parse the template
	t, err := template.New("protocolIDs").Parse(tmpl)
	if err != nil {
		fmt.Printf("Error parsing template: %v\n", err)
		return
	}

	// Create the output file
	file, err := os.Create(outputFile)
	if err != nil {
		fmt.Printf("Error creating file %s: %v\n", outputFile, err)
		return
	}
	defer file.Close()

	// Execute the template
	err = t.Execute(file, mapping)
	if err != nil {
		fmt.Printf("Error executing template: %v\n", err)
		return
	}

	if *debugMode {
		fmt.Printf("Generated protocol ID file: %s\n", outputFile)
	}
}
